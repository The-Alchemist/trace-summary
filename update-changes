#! /usr/bin/env bash
#
# Assembles a draft CHANGES entry out of recent commits. The entry is prepended
# to the current CHANGES file and the user then gets a chance to further edit
# the it in the editor before it gets committed. Also updates the VERSION file.

function normed_git_describe
{
    # $1 may be emty.
    echo -n `git describe --always $1 2>/dev/null | sed 's/^v//g' | sed "s/-[^-]*$//g" | sed 's/ //g'`
}

if [ "$1" == "-I" ]; then
    echo Initializing CHANGES file.
    init=1
fi

changes=CHANGES
version=VERSION

tmp=${changes}.tmp
trap "rm -f $tmp" EXIT

version_short=`normed_git_describe`
version_full=`git describe 2>/dev/null  | sed 's/^v//g'`

if [ "$version_short" == "" ]; then
    echo "can't generate version_short string"
    exit 1
fi

if [ "$init" == "1" ]; then
   echo >>$changes
   printf '%s | ' $version_short >$changes
   git show -s "--pretty=tformat:%ci" master >>$changes
   echo >>$changes
   echo "  * Starting $changes." >>$changes
   exit 0
fi

# Get the last revision for which we recorded entries.
last=`cat $changes | awk '{print $1}' | egrep '[0-9]+\.[0-9]+' | head -1 | sed 's/ //g'`

if [ "$last" = "" ]; then
    echo "Warning: cannot find previous entry, assuming all is new ..."
else
    echo "New revisions since" $last
fi

echo

rm -f $tmp
printf '%s | ' $version_short >$tmp
git show -s "--pretty=tformat:%ci" master >>$tmp
echo >>$tmp

found=0

for rev in `git rev-list --date-order --no-merges master`; do

   rev_describe=`normed_git_describe $rev`

   if [ "$rev_describe" == "$last" ]; then
       break;
   fi

   git show -s "--pretty=tformat:  %h | %aN | %s" $rev | cat

   author=`git show -s "--pretty=format:%aN" $rev`
   msg=`git show -s "--pretty=format:%B" $rev`

   if [ "$msg" != "" ]; then
       ( echo -n "$msg"; printf " (%s)" "$author" ) | awk 'NR==1{printf "  * %s\n", $0; next }{printf "    %s\n", $0}' >>$tmp
       echo >>$tmp
       found=1
   fi

done

if [ "$found" == "0" ]; then
    echo "  None."
    echo
    exit 0
fi

cat $changes >>$tmp

echo

# If we are ahead of origin, we can amend. If not, we need to create a new commit.
if git status | grep -q "is ahead of 'origin/master'"; then
    echo CHANGES modifications will be amended to last commit.
    amend=1
else
    echo CHANGES modifications will become a new commit.
    amend=0
fi

echo
echo Type Enter to edit new $changes, or CTRL-C to abort without changes. 
read
eval $EDITOR $tmp

rm -f $changes.bak
mv $tmp $changes
echo $version_short >$version

git add $changes $version

if [ "$amend" == "1" ]; then
    git commit --amend
else
    git commit
fi

echo "Old $tmp in saved in ${changes}.bak."
echo "Set $version to $version_short."

